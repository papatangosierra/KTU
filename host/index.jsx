// Kodansha indesign utilities host script// Paul Starr, June 2018#targetengine "session"; // not needed in Illustrator/AfterEffects// THIS GIVE US JSON, WHICH WE DEFINITELY NEED.#include "json2.js"// Set up window to use for progress bar when reversing pages, but don't display yet.var w = new Window ("palette"); // must be defined at top levelvar myMessage = w.add ("statictext"); myMessage.text = "Reversing page order...";// Figure out which version of common lettering fonts this document is using.var usedFonts = app.activeDocument.fonts;var myCCWildWordsRom = '';var myCCWildWordsItal = '';var myCCWildWordsBoldItal = '';var myCCComiccrazyRom = '';var myCCComiccrazyItal = '';var myCCComiccrazyBoldItal = '';var myCCAstroCityRom = '';var myCCAstroCityItal = '';var myCCAstroCityBoldItal = '';// Iterate over usedFonts in the current document; when we find a match for regular expressions// matching the font name, we remember that font for later use.for (var i=0; i < usedFonts.length; i++) {    if (/wildwords/i.test(usedFonts[i].name) && /regular/i.test(usedFonts[i].name)) {            myCCWildWordsRom = usedFonts[i];    }    if (/wildwords/i.test(usedFonts[i].name) && /ital/i.test(usedFonts[i].name)) {            myCCWildWordsItal = usedFonts[i];    }    if (/wildwords/i.test(usedFonts[i].name) && /bold/i.test(usedFonts[i].name)) {            myCCWildWordsBoldItal = usedFonts[i];    }    if (/comiccrazy/i.test(usedFonts[i].name) && /regular/i.test(usedFonts[i].name)) {            myCCComiccrazyRom = usedFonts[i];    }    if (/comiccrazy/i.test(usedFonts[i].name) && /ital/i.test(usedFonts[i].name)) {            myCCComiccrazyItal = usedFonts[i];    }    if (/comiccrazy/i.test(usedFonts[i].name) && /bold/i.test(usedFonts[i].name)) {            myCCComiccrazyBoldItal = usedFonts[i];    }    if (/wildwords/i.test(usedFonts[i].name) && /regular/i.test(usedFonts[i].name)) {            myCCWildWordsRom = usedFonts[i];    }    if (/wildwords/i.test(usedFonts[i].name) && /ital/i.test(usedFonts[i].name)) {            myCCWildWordsItal = usedFonts[i];    }    if (/comiccrazy/i.test(usedFonts[i].name) && /bold/i.test(usedFonts[i].name)) {            myCCWildWordsBoldItal = usedFonts[i];    }}// GREP Shortcuts// first, a utility function to generate a YAML report of text changedfunction getChangeReport(myFoundItems) {	var myReportArray = [];	for (var i=0; i < myFoundItems.length; i++) {		myReportArray.push({			'page' : myFoundItems[i].parentTextFrames[0].parentPage.name,			'text' : myFoundItems[i].parentTextFrames[0].contents		})	}	return myReportArray}// three dots -> typographical ellipsisfunction fixEllipses() {	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.findWhat = '\\.\\.\\.';    app.changeGrepPreferences.changeTo = '~e';	// effect the pattern change    var myFoundItems = app.activeDocument.changeGrep();    // then generate a report and return it to the calling script	return JSON.stringify(getChangeReport(app.activeDocument.changeGrep()))}// non-personal pronoun "I" to lower-case (unserifed) i in CCWildWords and CCAstroCity, all variantsfunction fixUnserif() {	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCWildWordsRom;    app.findGrepPreferences.findWhat = '([a-zA-Z]+)?I([a-zA-Z]+)';    app.changeGrepPreferences.changeTo = '$1i$2';    var myFoundItems = app.activeDocument.changeGrep().length; // we may as well keep track of found items    	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCWildWordsItal;    app.findGrepPreferences.findWhat = '([a-zA-Z]+)?I([a-zA-Z]+)';    app.changeGrepPreferences.changeTo = '$1i$2';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCWildWordsBoldItal;    app.findGrepPreferences.findWhat = '([a-zA-Z]+)?I([a-zA-Z]+)';    app.changeGrepPreferences.changeTo = '$1i$2';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count    	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCAstroCityRom;    app.findGrepPreferences.findWhat = '([a-zA-Z]+)?I([a-zA-Z]+)';    app.changeGrepPreferences.changeTo = '$1i$2';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count    	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCAstroCityItal;    app.findGrepPreferences.findWhat = '([a-zA-Z]+)?I([a-zA-Z]+)';    app.changeGrepPreferences.changeTo = '$1i$2';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCAstroCityBoldItal;    app.findGrepPreferences.findWhat = '([a-zA-Z]+)?I([a-zA-Z]+)';    app.changeGrepPreferences.changeTo = '$1i$2';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count	return JSON.stringify(getChangeReport(app.activeDocument.changeGrep()))}// Find left single quotes preceding "sup" and "cause" and change to right single quotes// (i.e., apostrophes)function fixCause() {	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.findWhat = '(~[)([Ss]up|[Cc]ause|[Cc]os|[Tt]il|[Ee]m)';    app.changeGrepPreferences.changeTo = "~'$2";    var myFoundItems = app.activeDocument.changeGrep().length;	return JSON.stringify(getChangeReport(app.activeDocument.changeGrep()))}// Find personal pronoun "I" characters in CCComiccrazy, and change to the pipe "|" character,// which that font uses to generate a serifed "I".function fixSerif() {	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCComiccrazyRom;    app.findGrepPreferences.findWhat = "(^| )([iI])([ |'|,|.|-|—|!|?|~e])";    app.changeGrepPreferences.changeTo = '$1|$3';    var myFoundItems = app.activeDocument.changeGrep().length;	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCComiccrazyItal;    app.findGrepPreferences.findWhat = "(^| )([iI])([ |'|,|.|-|—|!|?|~e])";    app.changeGrepPreferences.changeTo = '$1|$3';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.appliedFont = myCCComiccrazyBoldItal;    app.findGrepPreferences.findWhat = "(^| )([iI])([ |'|,|.|-|—|!|?|~e])";    app.changeGrepPreferences.changeTo = '$1|$3';    myFoundItems += app.activeDocument.changeGrep().length; // add additional instances found to running count	return JSON.stringify(getChangeReport(app.activeDocument.changeGrep()))}function fixOrdinals() {	app.changeGrepPreferences = NothingEnum.nothing;	app.findGrepPreferences = NothingEnum.nothing;    app.findGrepPreferences.findWhat = '(?<=\\d)(st|nd|rd|th)'; // Remember that backslashes in regular expressions stored in .findWhat have to be escaped in order to be properly passed! Which is BANANAS    app.changeGrepPreferences.changeTo = '$1';    app.changeGrepPreferences.position = Position.SUPERSCRIPT;    var myFoundItems = [].push(app.activeDocument.changeGrep());	return JSON.stringify(getChangeReport(app.activeDocument.changeGrep()))}// EXPORT SHORTCUTS// takes a space-delineated list of page numbers as its argument.function exportIndividualPages(pagesString) {    pageNumbers = pagesString.split(" ") // parse apart string received from panel    for (var i = 0; i < pageNumbers.length; i++) {        app.pdfExportPreferences.pageRange = pageNumbers[i].toString(); // select current page        var myExportPreset = app.pdfExportPresets.item('Kodansha')        if (app.activeDocument.documentPreferences.pageBinding == PageBindingOptions.leftToRight) { // If the book is bound left-to-right, it's also going to be lettered bottom-to-top, which means we can take the document page number to be the sequence number            app.activeDocument.exportFile(ExportFormat.PDF_TYPE, File(app.activeDocument.filePath + '/' + app.activeDocument.filePath.displayName + "_seq " + pageNumbers[i].toString()), false, myExportPreset); // export current page with sequence number appended to filename        }        else { // if the book is bound right-to-left, it's lettered top-to-bottom, which means we need to derive the sequence number for file naming            var sequenceNumber = (app.activeDocument.pages.length + 1) - parseInt(pageNumbers[i]); // The last page in the document would be sequence 1            app.activeDocument.exportFile(ExportFormat.PDF_TYPE, File(app.activeDocument.filePath + '/' + app.activeDocument.filePath.displayName + "_seq " + sequenceNumber.toString()), false, myExportPreset); // export current page with sequence number appended to filename        }       }}// Pagination and layout utilities// Reverse Binding Direction (uses ternary operator!! bc i'm so clever)function reverseBindingDirection() {    app.activeDocument.documentPreferences.allowPageShuffle = true;    app.activeDocument.documentPreferences.preserveLayoutWhenShuffling = false; // we lock things before shuffling the layout, so this can stay false        (app.activeDocument.documentPreferences.pageBinding == PageBindingOptions.rightToLeft) ?            app.activeDocument.documentPreferences.pageBinding = PageBindingOptions.leftToRight :             app.activeDocument.documentPreferences.pageBinding = PageBindingOptions.rightToLeft;        }function reversePageOrder() {    if (!w.pbar) { // if the progress bar doesn't exist        w.pbar = w.add('progressbar', undefined, 0, app.activeDocument.spreads.length);     } else {        w.pbar.value = 0;        w.update();    }    w.pbar.preferredSize.width = 300;    w.show(); // Show our progress bar window    var refpage = 0;    for (var i = 0; i < app.activeDocument.spreads.length; i++) { // move by spread, not page, so as not to fuck up formatting        if (i != 0) {            targetpage = app.activeDocument.spreads[i];            targetpage.move(LocationOptions.BEFORE, refpage);            refpage = targetpage;        } else {            refpage = app.activeDocument.spreads[i];        }        w.pbar.value = i + 1;        w.update(); // Have to call this, or the progress bar won't update.    }    w.close();}// Call This to flip bookfunction reverseOrderAndBindingDirection() {    reversePageOrder();    lockAllItems();    reverseBindingDirection();    unlockAllItems();}// Object utilitiesfunction unlockAllItems() {    app.activeDocument.pageItems.everyItem().locked = false;  }function lockAllItems () {    app.activeDocument.pageItems.everyItem().locked = true;  }// WORK IN PROGRESS: GET DIALOG STRUCTURE:function getTextStructure(theLayer) { // takes a layer name as an argument and returns a nested object with keys for each page, with each page key pointing to an object with key-value pairs for every text frame.     var dialogPages = {}; // dialogPages will be an object with n key-value pairs. Each key will be a string containing the page name (i.e., page number) and each value will be an object of the textFrames on that page, keys being labels and values being dialog    for (var i = 0; i < app.activeDocument.pages.length; i++) { // loop over pages        dialogPages[app.activeDocument.pages[i].name] = {}; // Add an empty object keyed to the number of every page we iterate over.         var frameLabel = 1; // initialize the frameLabel on each page        for (var j = app.activeDocument.pages[i].textFrames.length - 1; j >= 0; j--) { // loop over textFrames BACKWARDS; the highest-indexed textFrame in textFrames is the first one to be placed            if (app.activeDocument.pages[i].textFrames[j].itemLayer.name == theLayer) { // If a textFrame is on the specified layer (e.g. 'Dialog', 'SFX')                app.activeDocument.pages[i].textFrames[j].name = 'Text ' + frameLabel.toString(); // assign the name                frameLabel++; // increment the frameLabel                dialogPages[app.activeDocument.pages[i].name][app.activeDocument.pages[i].textFrames[j].name] = app.activeDocument.pages[i].textFrames[j].contents // add the key-value pair to the page object            }        }    }    return JSON.stringify(dialogPages); // return the textFrames object}// This is the setter function that the panel calls repeatedly to place text found in YAML scriptfunction setTextFrameContents(pageNumber, textFrameLabel, newText) {    app.activeDocument.pages.itemByName(pageNumber).textFrames.itemByName(textFrameLabel).contents = newText;}function getCurrentSpreadPages() { // returns array of page numbers being viewed on the current spread    var currentPages = app.activeWindow.activeSpread.pages    var pageNumbers = [];    for (var i=0; i < currentPages.length; i++) {        pageNumbers.push(currentPages[i].name)    }    return JSON.stringify(pageNumbers); // we have to parse the return value out as JSON because it's going to the CEP panel}